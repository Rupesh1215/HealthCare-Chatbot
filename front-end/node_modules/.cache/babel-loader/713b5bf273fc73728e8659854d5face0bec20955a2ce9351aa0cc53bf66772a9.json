{"ast":null,"code":"class SpeechSynthesis {\n  constructor() {\n    this.synth = window.speechSynthesis;\n    this.voices = [];\n    this.selectedVoice = null;\n    this.rate = 0.9; // Slower rate for better understanding\n    this.pitch = 1.0;\n    this.volume = 1.0;\n    this.isInitialized = false;\n  }\n  async init() {\n    return new Promise(resolve => {\n      const loadVoices = () => {\n        this.voices = this.synth.getVoices();\n        if (this.voices.length > 0) {\n          console.log('Available voices:', this.voices.map(v => `${v.name} (${v.lang})`));\n          this.isInitialized = true;\n          resolve();\n        } else {\n          setTimeout(loadVoices, 100);\n        }\n      };\n      if (this.synth.getVoices().length > 0) {\n        loadVoices();\n      } else {\n        this.synth.onvoiceschanged = loadVoices;\n      }\n    });\n  }\n  selectVoice(language = 'en-US') {\n    console.log('Selecting voice for language:', language);\n\n    // Language to voice mapping\n    const languageToVoice = {\n      'en-US': ['Microsoft David', 'Google US English', 'English'],\n      'hi-IN': ['Microsoft Hemant', 'Google हिन्दी', 'Hindi', 'hi'],\n      'te-IN': ['Microsoft Chitra', 'Telugu', 'te'],\n      'ta-IN': ['Microsoft Valluvar', 'Tamil', 'ta'],\n      'kn-IN': ['Microsoft Heera', 'Kannada', 'kn'],\n      'ml-IN': ['Microsoft Midhun', 'Malayalam', 'ml']\n    };\n    const targetVoices = languageToVoice[language] || languageToVoice['en-US'];\n\n    // Try to find exact match first\n    let voice = this.voices.find(v => v.lang === language || v.lang.startsWith(language.split('-')[0]));\n\n    // Fallback: try to find voice by name containing language keywords\n    if (!voice) {\n      voice = this.voices.find(v => targetVoices.some(keyword => v.name.includes(keyword) || v.lang.includes(keyword)));\n    }\n\n    // Final fallback: any voice that supports the language\n    if (!voice) {\n      voice = this.voices.find(v => v.lang.includes(language.split('-')[0]));\n    }\n\n    // Ultimate fallback: first available voice\n    if (!voice && this.voices.length > 0) {\n      voice = this.voices[0];\n    }\n    this.selectedVoice = voice;\n    console.log('Selected voice:', voice ? `${voice.name} (${voice.lang})` : 'No voice found');\n  }\n\n  // Enhanced text cleaning function for speech\n  cleanTextForSpeech(text) {\n    if (typeof text !== 'string') return String(text);\n    console.log('Original text for speech:', text);\n\n    // For Indian languages, preserve the native text but clean formatting\n    let cleanedText = text\n    // Remove markdown formatting but keep the text\n    .replace(/\\*\\*(.*?)\\*\\*/g, '$1').replace(/\\*(.*?)\\*/g, '$1').replace(/`(.*?)`/g, '$1').replace(/#{1,6}\\s?/g, '').replace(/```[\\s\\S]*?```/g, '').replace(/\\[(.*?)\\]\\(.*?\\)/g, '$1').replace(/<[^>]*>/g, '')\n\n    // Remove special characters but preserve language characters\n    .replace(/[*#~`_]/g, ' ')\n\n    // Handle lists and formatting\n    .replace(/\\n\\s*[-*•]\\s*/g, '. ').replace(/\\n\\s*\\d+\\.\\s*/g, '. ')\n\n    // Clean up excessive whitespace\n    .replace(/\\s+/g, ' ').replace(/\\n+/g, '. ').trim();\n\n    // For Indian languages, we want to preserve the native script\n    // Only clean excessive punctuation that might cause issues\n    cleanedText = cleanedText.replace(/\\s*\\.\\s*\\.\\s*\\./g, '. ').replace(/\\s{2,}/g, ' ');\n    console.log('Cleaned text for speech:', cleanedText);\n    return cleanedText;\n  }\n  async speak(text, language = 'en-US') {\n    if (!this.isInitialized) {\n      await this.init();\n    }\n    if (this.synth.speaking) {\n      this.synth.cancel();\n      // Small delay to ensure cancellation is complete\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    this.selectVoice(language);\n\n    // Clean the text before speaking\n    const cleanedText = this.cleanTextForSpeech(text);\n    if (!cleanedText || cleanedText.trim().length === 0) {\n      console.log('No text to speak after cleaning');\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const utterance = new SpeechSynthesisUtterance(cleanedText);\n      if (this.selectedVoice) {\n        utterance.voice = this.selectedVoice;\n        utterance.lang = this.selectedVoice.lang;\n      } else {\n        utterance.lang = language;\n      }\n      utterance.rate = this.rate;\n      utterance.pitch = this.pitch;\n      utterance.volume = this.volume;\n      utterance.onstart = () => {\n        console.log('Speech started for language:', language);\n        console.log('Using voice:', utterance.voice ? utterance.voice.name : 'default');\n      };\n      utterance.onend = () => {\n        console.log('Speech synthesis completed');\n        resolve();\n      };\n      utterance.onerror = event => {\n        console.error('Speech synthesis error:', event);\n        reject(new Error(`Speech synthesis failed: ${event.error}`));\n      };\n\n      // Add a small delay before speaking to ensure everything is ready\n      setTimeout(() => {\n        try {\n          this.synth.speak(utterance);\n        } catch (error) {\n          console.error('Error speaking utterance:', error);\n          reject(error);\n        }\n      }, 50);\n    });\n  }\n  stop() {\n    this.synth.cancel();\n  }\n  isSpeaking() {\n    return this.synth.speaking;\n  }\n  getAvailableVoices() {\n    return this.voices;\n  }\n\n  // Check if browser supports speech synthesis\n  isSupported() {\n    return 'speechSynthesis' in window;\n  }\n}\n\n// Create a singleton instance\nexport const speechSynthesizer = new SpeechSynthesis();\n\n// Initialize on import but don't block\nspeechSynthesizer.init().catch(error => {\n  console.error('Speech synthesis initialization failed:', error);\n});","map":{"version":3,"names":["SpeechSynthesis","constructor","synth","window","speechSynthesis","voices","selectedVoice","rate","pitch","volume","isInitialized","init","Promise","resolve","loadVoices","getVoices","length","console","log","map","v","name","lang","setTimeout","onvoiceschanged","selectVoice","language","languageToVoice","targetVoices","voice","find","startsWith","split","some","keyword","includes","cleanTextForSpeech","text","String","cleanedText","replace","trim","speak","speaking","cancel","reject","utterance","SpeechSynthesisUtterance","onstart","onend","onerror","event","error","Error","stop","isSpeaking","getAvailableVoices","isSupported","speechSynthesizer","catch"],"sources":["C:/Users/mohan/OneDrive/Desktop/Chatbot/front-end/src/utils/speechSynthesis.js"],"sourcesContent":["class SpeechSynthesis {\r\n  constructor() {\r\n    this.synth = window.speechSynthesis;\r\n    this.voices = [];\r\n    this.selectedVoice = null;\r\n    this.rate = 0.9; // Slower rate for better understanding\r\n    this.pitch = 1.0;\r\n    this.volume = 1.0;\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  async init() {\r\n    return new Promise((resolve) => {\r\n      const loadVoices = () => {\r\n        this.voices = this.synth.getVoices();\r\n        if (this.voices.length > 0) {\r\n          console.log('Available voices:', this.voices.map(v => `${v.name} (${v.lang})`));\r\n          this.isInitialized = true;\r\n          resolve();\r\n        } else {\r\n          setTimeout(loadVoices, 100);\r\n        }\r\n      };\r\n\r\n      if (this.synth.getVoices().length > 0) {\r\n        loadVoices();\r\n      } else {\r\n        this.synth.onvoiceschanged = loadVoices;\r\n      }\r\n    });\r\n  }\r\n\r\n  selectVoice(language = 'en-US') {\r\n    console.log('Selecting voice for language:', language);\r\n    \r\n    // Language to voice mapping\r\n    const languageToVoice = {\r\n      'en-US': ['Microsoft David', 'Google US English', 'English'],\r\n      'hi-IN': ['Microsoft Hemant', 'Google हिन्दी', 'Hindi', 'hi'],\r\n      'te-IN': ['Microsoft Chitra', 'Telugu', 'te'],\r\n      'ta-IN': ['Microsoft Valluvar', 'Tamil', 'ta'],\r\n      'kn-IN': ['Microsoft Heera', 'Kannada', 'kn'],\r\n      'ml-IN': ['Microsoft Midhun', 'Malayalam', 'ml']\r\n    };\r\n\r\n    const targetVoices = languageToVoice[language] || languageToVoice['en-US'];\r\n    \r\n    // Try to find exact match first\r\n    let voice = this.voices.find(v => \r\n      v.lang === language || v.lang.startsWith(language.split('-')[0])\r\n    );\r\n    \r\n    // Fallback: try to find voice by name containing language keywords\r\n    if (!voice) {\r\n      voice = this.voices.find(v => \r\n        targetVoices.some(keyword => \r\n          v.name.includes(keyword) || v.lang.includes(keyword)\r\n        )\r\n      );\r\n    }\r\n    \r\n    // Final fallback: any voice that supports the language\r\n    if (!voice) {\r\n      voice = this.voices.find(v => \r\n        v.lang.includes(language.split('-')[0])\r\n      );\r\n    }\r\n    \r\n    // Ultimate fallback: first available voice\r\n    if (!voice && this.voices.length > 0) {\r\n      voice = this.voices[0];\r\n    }\r\n    \r\n    this.selectedVoice = voice;\r\n    console.log('Selected voice:', voice ? `${voice.name} (${voice.lang})` : 'No voice found');\r\n  }\r\n\r\n  // Enhanced text cleaning function for speech\r\n  cleanTextForSpeech(text) {\r\n    if (typeof text !== 'string') return String(text);\r\n    \r\n    console.log('Original text for speech:', text);\r\n    \r\n    // For Indian languages, preserve the native text but clean formatting\r\n    let cleanedText = text\r\n      // Remove markdown formatting but keep the text\r\n      .replace(/\\*\\*(.*?)\\*\\*/g, '$1')\r\n      .replace(/\\*(.*?)\\*/g, '$1')\r\n      .replace(/`(.*?)`/g, '$1')\r\n      .replace(/#{1,6}\\s?/g, '')\r\n      .replace(/```[\\s\\S]*?```/g, '')\r\n      .replace(/\\[(.*?)\\]\\(.*?\\)/g, '$1')\r\n      .replace(/<[^>]*>/g, '')\r\n      \r\n      // Remove special characters but preserve language characters\r\n      .replace(/[*#~`_]/g, ' ')\r\n      \r\n      // Handle lists and formatting\r\n      .replace(/\\n\\s*[-*•]\\s*/g, '. ')\r\n      .replace(/\\n\\s*\\d+\\.\\s*/g, '. ')\r\n      \r\n      // Clean up excessive whitespace\r\n      .replace(/\\s+/g, ' ')\r\n      .replace(/\\n+/g, '. ')\r\n      .trim();\r\n\r\n    // For Indian languages, we want to preserve the native script\r\n    // Only clean excessive punctuation that might cause issues\r\n    cleanedText = cleanedText\r\n      .replace(/\\s*\\.\\s*\\.\\s*\\./g, '. ')\r\n      .replace(/\\s{2,}/g, ' ');\r\n\r\n    console.log('Cleaned text for speech:', cleanedText);\r\n    return cleanedText;\r\n  }\r\n\r\n  async speak(text, language = 'en-US') {\r\n    if (!this.isInitialized) {\r\n      await this.init();\r\n    }\r\n\r\n    if (this.synth.speaking) {\r\n      this.synth.cancel();\r\n      // Small delay to ensure cancellation is complete\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n\r\n    this.selectVoice(language);\r\n\r\n    // Clean the text before speaking\r\n    const cleanedText = this.cleanTextForSpeech(text);\r\n    \r\n    if (!cleanedText || cleanedText.trim().length === 0) {\r\n      console.log('No text to speak after cleaning');\r\n      return Promise.resolve();\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const utterance = new SpeechSynthesisUtterance(cleanedText);\r\n      \r\n      if (this.selectedVoice) {\r\n        utterance.voice = this.selectedVoice;\r\n        utterance.lang = this.selectedVoice.lang;\r\n      } else {\r\n        utterance.lang = language;\r\n      }\r\n      \r\n      utterance.rate = this.rate;\r\n      utterance.pitch = this.pitch;\r\n      utterance.volume = this.volume;\r\n\r\n      utterance.onstart = () => {\r\n        console.log('Speech started for language:', language);\r\n        console.log('Using voice:', utterance.voice ? utterance.voice.name : 'default');\r\n      };\r\n      \r\n      utterance.onend = () => {\r\n        console.log('Speech synthesis completed');\r\n        resolve();\r\n      };\r\n      \r\n      utterance.onerror = (event) => {\r\n        console.error('Speech synthesis error:', event);\r\n        reject(new Error(`Speech synthesis failed: ${event.error}`));\r\n      };\r\n\r\n      // Add a small delay before speaking to ensure everything is ready\r\n      setTimeout(() => {\r\n        try {\r\n          this.synth.speak(utterance);\r\n        } catch (error) {\r\n          console.error('Error speaking utterance:', error);\r\n          reject(error);\r\n        }\r\n      }, 50);\r\n    });\r\n  }\r\n\r\n  stop() {\r\n    this.synth.cancel();\r\n  }\r\n\r\n  isSpeaking() {\r\n    return this.synth.speaking;\r\n  }\r\n\r\n  getAvailableVoices() {\r\n    return this.voices;\r\n  }\r\n\r\n  // Check if browser supports speech synthesis\r\n  isSupported() {\r\n    return 'speechSynthesis' in window;\r\n  }\r\n}\r\n\r\n// Create a singleton instance\r\nexport const speechSynthesizer = new SpeechSynthesis();\r\n\r\n// Initialize on import but don't block\r\nspeechSynthesizer.init().catch(error => {\r\n  console.error('Speech synthesis initialization failed:', error);\r\n});"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}