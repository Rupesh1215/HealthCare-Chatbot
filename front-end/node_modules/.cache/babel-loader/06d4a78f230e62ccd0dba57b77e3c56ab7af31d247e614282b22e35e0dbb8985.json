{"ast":null,"code":"class SpeechSynthesis {\n  constructor() {\n    this.synth = window.speechSynthesis;\n    this.voices = [];\n    this.selectedVoice = null;\n    this.rate = 0.9; // Slower for better understanding\n    this.pitch = 1.0;\n    this.volume = 1.0;\n    this.isInitialized = false;\n  }\n  async init() {\n    return new Promise((resolve, reject) => {\n      // Check if speech synthesis is supported\n      if (!this.isSupported()) {\n        reject(new Error('Speech synthesis not supported'));\n        return;\n      }\n      const loadVoices = () => {\n        this.voices = this.synth.getVoices();\n        if (this.voices.length > 0) {\n          console.log('Available voices:', this.voices.map(v => `${v.name} (${v.lang})`));\n          this.isInitialized = true;\n          resolve();\n        }\n      };\n\n      // Load voices immediately if available\n      if (this.synth.getVoices().length > 0) {\n        loadVoices();\n      } else {\n        // Wait for voices to be loaded\n        this.synth.onvoiceschanged = loadVoices;\n\n        // Timeout fallback\n        setTimeout(() => {\n          if (!this.isInitialized && this.synth.getVoices().length > 0) {\n            loadVoices();\n          } else if (!this.isInitialized) {\n            reject(new Error('Failed to load voices within timeout'));\n          }\n        }, 3000);\n      }\n    });\n  }\n  selectVoice(language = 'en-US') {\n    console.log('Selecting voice for language:', language);\n    if (this.voices.length === 0) {\n      console.warn('No voices available');\n      this.selectedVoice = null;\n      return;\n    }\n\n    // Try to find exact language match first\n    let voice = this.voices.find(v => v.lang === language);\n\n    // Fallback to language family match (e.g., te-IN -> te)\n    if (!voice) {\n      const langPrefix = language.split('-')[0];\n      voice = this.voices.find(v => v.lang.startsWith(langPrefix));\n    }\n\n    // Fallback to any voice that might work\n    if (!voice) {\n      voice = this.voices.find(v => v.lang.includes('en')); // English fallback\n    }\n\n    // Ultimate fallback\n    if (!voice) {\n      voice = this.voices[0];\n    }\n    this.selectedVoice = voice;\n    console.log('Selected voice:', voice ? `${voice.name} (${voice.lang})` : 'No voice found');\n  }\n\n  // Enhanced text cleaning function for speech\n  cleanTextForSpeech(text) {\n    if (typeof text !== 'string') return String(text);\n\n    // Remove markdown and special characters but preserve the actual content\n    let cleanedText = text\n    // Remove markdown formatting but keep text\n    .replace(/\\*\\*(.*?)\\*\\*/g, '$1').replace(/\\*(.*?)\\*/g, '$1').replace(/`(.*?)`/g, '$1').replace(/#{1,6}\\s?/g, '').replace(/```[\\s\\S]*?```/g, '').replace(/\\[(.*?)\\]\\(.*?\\)/g, '$1').replace(/<[^>]*>/g, '')\n\n    // Remove special characters that might be read aloud\n    .replace(/[*#~`_]/g, ' ')\n\n    // Convert lists to natural speech\n    .replace(/\\n\\s*[-*â€¢]\\s*/g, '. ').replace(/\\n\\s*\\d+\\.\\s*/g, '. ')\n\n    // Clean up whitespace\n    .replace(/\\s+/g, ' ').replace(/\\n+/g, '. ').trim();\n\n    // Clean up punctuation for better speech flow\n    cleanedText = cleanedText.replace(/\\s*\\.\\s*\\.\\s*\\./g, '. ').replace(/\\s{2,}/g, ' ');\n\n    // Ensure proper sentence ending\n    if (cleanedText.length > 0 && !/[.!?]$/.test(cleanedText)) {\n      cleanedText += '.';\n    }\n    return cleanedText;\n  }\n  async speak(text, language = 'en-US') {\n    if (!this.isSupported()) {\n      throw new Error('Speech synthesis not supported');\n    }\n    if (!this.isInitialized) {\n      await this.init();\n    }\n\n    // Cancel any ongoing speech\n    if (this.synth.speaking) {\n      this.synth.cancel();\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n    this.selectVoice(language);\n\n    // Clean the text\n    const cleanedText = this.cleanTextForSpeech(text);\n    if (!cleanedText || cleanedText.trim().length === 0) {\n      throw new Error('No text to speak after cleaning');\n    }\n    return new Promise((resolve, reject) => {\n      const utterance = new SpeechSynthesisUtterance(cleanedText);\n\n      // Set voice properties\n      if (this.selectedVoice) {\n        utterance.voice = this.selectedVoice;\n        utterance.lang = this.selectedVoice.lang;\n      } else {\n        utterance.lang = language;\n      }\n      utterance.rate = this.rate;\n      utterance.pitch = this.pitch;\n      utterance.volume = this.volume;\n      utterance.onstart = () => {\n        console.log('Speech started');\n        console.log('Language:', utterance.lang);\n        console.log('Voice:', utterance.voice ? utterance.voice.name : 'default');\n      };\n      utterance.onend = () => {\n        console.log('Speech completed successfully');\n        resolve();\n      };\n      utterance.onerror = event => {\n        console.error('Speech error:', event);\n        reject(new Error(`Speech synthesis failed: ${event.error}`));\n      };\n\n      // Speak with a small delay to ensure setup is complete\n      setTimeout(() => {\n        try {\n          this.synth.speak(utterance);\n        } catch (error) {\n          console.error('Error starting speech:', error);\n          reject(error);\n        }\n      }, 50);\n    });\n  }\n  stop() {\n    if (this.isSupported()) {\n      this.synth.cancel();\n    }\n  }\n  isSpeaking() {\n    return this.isSupported() ? this.synth.speaking : false;\n  }\n  isSupported() {\n    return 'speechSynthesis' in window;\n  }\n  getAvailableVoices() {\n    return this.voices;\n  }\n  getAvailableLanguages() {\n    const languages = new Set();\n    this.voices.forEach(voice => {\n      languages.add(voice.lang);\n    });\n    return Array.from(languages);\n  }\n}\n\n// Create and export singleton instance\nexport const speechSynthesizer = new SpeechSynthesis();\n\n// Auto-initialize but don't block\nif (speechSynthesizer.isSupported()) {\n  speechSynthesizer.init().catch(error => {\n    console.warn('Speech synthesis initialization warning:', error.message);\n  });\n}","map":{"version":3,"names":["SpeechSynthesis","constructor","synth","window","speechSynthesis","voices","selectedVoice","rate","pitch","volume","isInitialized","init","Promise","resolve","reject","isSupported","Error","loadVoices","getVoices","length","console","log","map","v","name","lang","onvoiceschanged","setTimeout","selectVoice","language","warn","voice","find","langPrefix","split","startsWith","includes","cleanTextForSpeech","text","String","cleanedText","replace","trim","test","speak","speaking","cancel","utterance","SpeechSynthesisUtterance","onstart","onend","onerror","event","error","stop","isSpeaking","getAvailableVoices","getAvailableLanguages","languages","Set","forEach","add","Array","from","speechSynthesizer","catch","message"],"sources":["C:/Users/mohan/OneDrive/Desktop/Chatbot/front-end/src/utils/speechSynthesis.js"],"sourcesContent":["class SpeechSynthesis {\r\n  constructor() {\r\n    this.synth = window.speechSynthesis;\r\n    this.voices = [];\r\n    this.selectedVoice = null;\r\n    this.rate = 0.9; // Slower for better understanding\r\n    this.pitch = 1.0;\r\n    this.volume = 1.0;\r\n    this.isInitialized = false;\r\n  }\r\n\r\n  async init() {\r\n    return new Promise((resolve, reject) => {\r\n      // Check if speech synthesis is supported\r\n      if (!this.isSupported()) {\r\n        reject(new Error('Speech synthesis not supported'));\r\n        return;\r\n      }\r\n\r\n      const loadVoices = () => {\r\n        this.voices = this.synth.getVoices();\r\n        if (this.voices.length > 0) {\r\n          console.log('Available voices:', this.voices.map(v => `${v.name} (${v.lang})`));\r\n          this.isInitialized = true;\r\n          resolve();\r\n        }\r\n      };\r\n\r\n      // Load voices immediately if available\r\n      if (this.synth.getVoices().length > 0) {\r\n        loadVoices();\r\n      } else {\r\n        // Wait for voices to be loaded\r\n        this.synth.onvoiceschanged = loadVoices;\r\n        \r\n        // Timeout fallback\r\n        setTimeout(() => {\r\n          if (!this.isInitialized && this.synth.getVoices().length > 0) {\r\n            loadVoices();\r\n          } else if (!this.isInitialized) {\r\n            reject(new Error('Failed to load voices within timeout'));\r\n          }\r\n        }, 3000);\r\n      }\r\n    });\r\n  }\r\n\r\n  selectVoice(language = 'en-US') {\r\n    console.log('Selecting voice for language:', language);\r\n    \r\n    if (this.voices.length === 0) {\r\n      console.warn('No voices available');\r\n      this.selectedVoice = null;\r\n      return;\r\n    }\r\n\r\n    // Try to find exact language match first\r\n    let voice = this.voices.find(v => v.lang === language);\r\n    \r\n    // Fallback to language family match (e.g., te-IN -> te)\r\n    if (!voice) {\r\n      const langPrefix = language.split('-')[0];\r\n      voice = this.voices.find(v => v.lang.startsWith(langPrefix));\r\n    }\r\n    \r\n    // Fallback to any voice that might work\r\n    if (!voice) {\r\n      voice = this.voices.find(v => v.lang.includes('en')); // English fallback\r\n    }\r\n    \r\n    // Ultimate fallback\r\n    if (!voice) {\r\n      voice = this.voices[0];\r\n    }\r\n    \r\n    this.selectedVoice = voice;\r\n    console.log('Selected voice:', voice ? `${voice.name} (${voice.lang})` : 'No voice found');\r\n  }\r\n\r\n  // Enhanced text cleaning function for speech\r\n  cleanTextForSpeech(text) {\r\n    if (typeof text !== 'string') return String(text);\r\n    \r\n    // Remove markdown and special characters but preserve the actual content\r\n    let cleanedText = text\r\n      // Remove markdown formatting but keep text\r\n      .replace(/\\*\\*(.*?)\\*\\*/g, '$1')\r\n      .replace(/\\*(.*?)\\*/g, '$1')\r\n      .replace(/`(.*?)`/g, '$1')\r\n      .replace(/#{1,6}\\s?/g, '')\r\n      .replace(/```[\\s\\S]*?```/g, '')\r\n      .replace(/\\[(.*?)\\]\\(.*?\\)/g, '$1')\r\n      .replace(/<[^>]*>/g, '')\r\n      \r\n      // Remove special characters that might be read aloud\r\n      .replace(/[*#~`_]/g, ' ')\r\n      \r\n      // Convert lists to natural speech\r\n      .replace(/\\n\\s*[-*â€¢]\\s*/g, '. ')\r\n      .replace(/\\n\\s*\\d+\\.\\s*/g, '. ')\r\n      \r\n      // Clean up whitespace\r\n      .replace(/\\s+/g, ' ')\r\n      .replace(/\\n+/g, '. ')\r\n      .trim();\r\n\r\n    // Clean up punctuation for better speech flow\r\n    cleanedText = cleanedText\r\n      .replace(/\\s*\\.\\s*\\.\\s*\\./g, '. ')\r\n      .replace(/\\s{2,}/g, ' ');\r\n\r\n    // Ensure proper sentence ending\r\n    if (cleanedText.length > 0 && !/[.!?]$/.test(cleanedText)) {\r\n      cleanedText += '.';\r\n    }\r\n\r\n    return cleanedText;\r\n  }\r\n\r\n  async speak(text, language = 'en-US') {\r\n    if (!this.isSupported()) {\r\n      throw new Error('Speech synthesis not supported');\r\n    }\r\n\r\n    if (!this.isInitialized) {\r\n      await this.init();\r\n    }\r\n\r\n    // Cancel any ongoing speech\r\n    if (this.synth.speaking) {\r\n      this.synth.cancel();\r\n      await new Promise(resolve => setTimeout(resolve, 100));\r\n    }\r\n\r\n    this.selectVoice(language);\r\n\r\n    // Clean the text\r\n    const cleanedText = this.cleanTextForSpeech(text);\r\n    \r\n    if (!cleanedText || cleanedText.trim().length === 0) {\r\n      throw new Error('No text to speak after cleaning');\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const utterance = new SpeechSynthesisUtterance(cleanedText);\r\n      \r\n      // Set voice properties\r\n      if (this.selectedVoice) {\r\n        utterance.voice = this.selectedVoice;\r\n        utterance.lang = this.selectedVoice.lang;\r\n      } else {\r\n        utterance.lang = language;\r\n      }\r\n      \r\n      utterance.rate = this.rate;\r\n      utterance.pitch = this.pitch;\r\n      utterance.volume = this.volume;\r\n\r\n      utterance.onstart = () => {\r\n        console.log('Speech started');\r\n        console.log('Language:', utterance.lang);\r\n        console.log('Voice:', utterance.voice ? utterance.voice.name : 'default');\r\n      };\r\n      \r\n      utterance.onend = () => {\r\n        console.log('Speech completed successfully');\r\n        resolve();\r\n      };\r\n      \r\n      utterance.onerror = (event) => {\r\n        console.error('Speech error:', event);\r\n        reject(new Error(`Speech synthesis failed: ${event.error}`));\r\n      };\r\n\r\n      // Speak with a small delay to ensure setup is complete\r\n      setTimeout(() => {\r\n        try {\r\n          this.synth.speak(utterance);\r\n        } catch (error) {\r\n          console.error('Error starting speech:', error);\r\n          reject(error);\r\n        }\r\n      }, 50);\r\n    });\r\n  }\r\n\r\n  stop() {\r\n    if (this.isSupported()) {\r\n      this.synth.cancel();\r\n    }\r\n  }\r\n\r\n  isSpeaking() {\r\n    return this.isSupported() ? this.synth.speaking : false;\r\n  }\r\n\r\n  isSupported() {\r\n    return 'speechSynthesis' in window;\r\n  }\r\n\r\n  getAvailableVoices() {\r\n    return this.voices;\r\n  }\r\n\r\n  getAvailableLanguages() {\r\n    const languages = new Set();\r\n    this.voices.forEach(voice => {\r\n      languages.add(voice.lang);\r\n    });\r\n    return Array.from(languages);\r\n  }\r\n}\r\n\r\n// Create and export singleton instance\r\nexport const speechSynthesizer = new SpeechSynthesis();\r\n\r\n// Auto-initialize but don't block\r\nif (speechSynthesizer.isSupported()) {\r\n  speechSynthesizer.init().catch(error => {\r\n    console.warn('Speech synthesis initialization warning:', error.message);\r\n  });\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}